"""
CPEN 400Q work
This file has helper methods to create as well as train the fully randomly and near 
unitary initialized circuits, take results from MPS and convert them into a quantum circuit, 
extend the quantum circuit created from MPS with SU(4) unitaries, and train the extended quantum circuit.

Author : @mushahidkhan835
"""

import matplotlib.pyplot as plt
import numpy as np
import pennylane as qml
from pennylane import numpy as pnp
import jax.numpy as jnp
import optax
import jax
import mps_circuit_helpers
import mps_circuits
import metrics
import mps_circuit_helpers as helpers

from tqdm import tqdm
from jax.config import config
config.update("jax_enable_x64", True)
from MPScumulant import MPS_c


maxi_bond = 2
chi = 'BStest/BS_project-2-MPS'    
m = MPS_c(12, max_bond_dim=maxi_bond)
mps_circ = None

def mps_to_unitaries_circuit():
    """
    Takes the result from MPS and convert it to a quantum circuit
    """
    mps_unitaries = helpers.get_mps_unitaries(m)
    mps_circ = mps_circuits.mps_unitaries_to_circuit(mps_unitaries)
    qml.drawer.draw_mpl(mps_circ, style="sketch")()
    return mps_circ

def get_expanded_tape():
    """
    Apply the `qml.transforms.unitary_to_rot` to construct the KAK-decomposed circuit

    Returns:
        pennylane.tape.qscript.QuantumScript: construct the KAK-decomposed circuit
    """
    return qml.transforms.unitary_to_rot.tape_fn(mps_circ._tape)
     
def get_details_for_su4_matrices(expanded_tape, n_wires):
    """
    Return the number of weights for special unitary matrices and the wires to add the special unitary matrices

    Args:
        expanded_tape (pennylane.tape.qscript.QuantumScript): KAK-decomposed circuit
        n_wires (int): number of wires
    """
    wires_connected = []
    wires_connected_len_2 = set()
    
    for op in expanded_tape.operations:
        w = list(op.wires)
        if len(w) > 1:
            wires_connected.append(list(op.wires))
            
    for w in wires_connected:
        for i in range(len(w) - 1):
            for j in range(i, len(w)):
                wires_connected_len_2.add((w[i], w[j]))

    wires_to_add_su4 = []
    total_num_weights = 0 
    for x in range(n_wires - 1):
        for j in range(x + 1, n_wires):
            if (x, j) not in wires_connected_len_2 and (j, x) not in wires_connected_len_2:
                wires_to_add_su4.append([x, j])
                total_num_weights += 1
    return total_num_weights, wires_to_add_su4
                
                
def get_extended_circuit(params, params1, shots=None):
    """
    Returns the circuit generated by MPS extended by special unitaries using all to all topology

    Args:
        params (list): list of parameters for the circuit generated by MPS
        params1 (list): list of parameters for the circuit extended
        shots (_type_, optional): number of shots for the quantum circuit. Defaults to None.

    Returns:
        qnode: qnode of circuit
    """
    expanded_tape =  get_expanded_tape()
    n_wires = expanded_tape.num_wires
    wires_to_add_su4 = get_details_for_su4_matrices(expanded_tape, n_wires)[1]
    
    dev = qml.device("default.qubit.jax", wires=n_wires, shots=shots)
    @qml.qnode(dev, interface="jax")
    def qnode():
        idx = 0
        for op in expanded_tape.operations:
            if op.num_params > 0:
                if op.name == "Rot":
                    op.__class__(*params[idx:idx+3], wires=op.wires)
                    idx += 3
                else:
                    op.__class__(params[idx], wires=op.wires)
                    idx += 1
            else:
                op.__class__(wires=op.wires)
                
        for i in range(len(wires_to_add_su4)):
            qml.SpecialUnitary(params1[i], wires=wires_to_add_su4[i])
        
        if shots is not None:
            return qml.sample()
        return qml.probs(wires=list(range(n_wires)))
    
    return qnode

def get_data_states(location, columns):
    """
    Given link, return bars and stripes data reshaped

    Args:
        location (string): location of the bars and stripes data
        columns (int): reshaping integer

    Returns:
        list: list of list of binary numbers
    """
    import os
    print(os.path.abspath("."))

    data = np.load(location)

    return data.reshape(-1, columns).astype(np.int8)

@jax.jit
def loss_mps_extended(init_val):
    """
    Loss function for randomly intialized for extended circuit

    Args:
        init_val (dictionary): dictionary of parameters to be optimized

    Returns:
        _type_: KL divergence
    """
    params = init_val['params']
    params1 = init_val['params1']

    probs = get_extended_circuit(params, params1)()
    filter_qc_probs = metrics.filter_probs(probs, get_data_states("BStest/b_s_4_3.npy", 12))
    return metrics.kl_divergence_synergy_paper(22, filter_qc_probs)


def get_random_initialized_circuit(params, shots = None, wires = 12):
    """
    Given a list of randomly initialized initialize a quantum
    circuit

    Args:
        params (list): List of params

    Returns:
        qml.QNode : Initialized quantum circuit
    """
    dev = qml.device("default.qubit", wires=wires, shots=shots)
    
    @qml.qnode(dev, interface="jax")
    def qnode():
        for i in range(11):
            qml.SpecialUnitary(params[i], wires=[i, i + 1])
            qml.SpecialUnitary(params[i + 11], wires=[i, i  + 1])
        
        for x in range(wires - 1):
            for j in range(x + 1, wires):
                qml.SpecialUnitary(params[i], wires=[x, j])
                i += 1

        if shots is not None:
            return qml.sample()
        
        return qml.probs(wires=list(range(wires)))
    
    return qnode


@jax.jit
def loss_random_near_unitary(init_val):
    """
    Loss function for randomly intialized and near unitary initialized weights

    Args:
        init_val (dictionary): dictionary of parameters to be optimized

    Returns:
        _type_: KL divergence
    """
    params = init_val['params']
    probs = get_random_initialized_circuit(params)()
    filter_qc_probs = metrics.filter_probs(probs, get_data_states("BStest/b_s_4_3.npy", 12))
    return metrics.kl_divergence_synergy_paper(22, filter_qc_probs)

def train_model(init_val, n_its=15000, learning_rate=1e-6, circuit_type="random_near_unitary"):
    """
    Train model

    Args:
        init_val (dictionary): dictionary of parameters to train
        n_init (int): number of iterations. Defaults to 15000.
        learning_rate (float): learning rate. Defaults to 1e-6.
        circuit_type (str, optional): the type of circuit to run. Defaults to "random_near_unitary".

    Returns:
        tuple: update values of parameters after training and the loss at each iteration
    """
    loss_track = []   
    opt_exc = optax.adam(learning_rate)
    opt_state = opt_exc.init(init_val)

    for _ in tqdm(range(n_its)):
        grads = None
        if circuit_type == "random_near_unitary":
            grads = jax.grad(loss_random_near_unitary)(init_val)
            updates, opt_state = opt_exc.update(grads, opt_state)
            init_val = optax.apply_updates(init_val, updates)
            loss_track.append(loss_random_near_unitary(init_val))
        else:
            grads = jax.grad(loss_mps_extended)(init_val)
            updates, opt_state = opt_exc.update(grads, opt_state)
            init_val = optax.apply_updates(init_val, updates)
            loss_track.append(loss_mps_extended(init_val))
    return init_val, loss_track
